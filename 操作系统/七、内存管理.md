## 七、内存管理
* 在单道程序设计中,主存储器（简称主存）被划分成两个部分：
  1. 一部分供操作系统使用(驻留监控程序、内存)
  2. 一部分供当前正在执行的程序使用
  
### 存储管理的主要目的
* 将内存区域进行划分以容纳多个进程(多道程序设计)
* 有效分配利于多道程序

### 7.1内存管理的需求
* 重定位
* 保护
* 共享
* 逻辑组织
* 物理组织<br>
(注:
	>物理地址：(绝对地址)内存的实际地址
	>逻辑地址：与内存无关的地址,一般操作逻辑地址，然后通过 段地址*16+偏移地址 来映射到物理地址
	>相对地址：相对于某一点(通常为起始地址)的逻辑地址
)

#### 7.1.1重定位
 * 程序每次重新换入磁盘时,如果放在和以前相同的内存区域，则是很大的限制。为避免这种情况，
	把再次换入进程时把进程分配到内存的不同区域，称之为重定位
	
#### 7.1.2保护
 * 每个进程都应当受到保护,以免被其他进程有意或者无意的干涉。
 * 由于程序在主存中的位置是不可预测的，因而在编译时候不可能检查绝对地址来确定保护。
	  因此，必须在运行时检查进程产生的所有存储器访问，以确保它们只访问了分配给该进程的存储空间
 * 通常操作内存保护的需求必须由处理器(硬件)来满足,而不是由操作系统(软件)来满足。
	因为操作系统不能预测程序可能产生的所有存储器访问

#### 7.1.3共享
 * 任何保护机制必须具有一定的灵活性，已允许多个进程访问主存的同一部分
 * 合作完成同一任务的进程可能需要访问同一数据结构

#### 7.1.4逻辑组织
 * 计算机系统中的主存总是被组织成线性的(或一维的)地址空间，并且地址空间是由一系列
 字节或字组成
#### 7.1.5物理组织
 * 计算机内存至少被组织成两级，称之为主存和辅存。
 * 主存提供快速的访问，代价也相对较高。主存是易失性的，它不能提供永久存储
 * 辅存比主存慢且便宜，它通常是非易失性的，大容量的辅存可以长期存储程序和数据
   ，而较小的主存用于保存当前使用的程序和数据
   
### 7.2内存分区
 * 现代多道程序设计系统中，涉及一种成为虚拟内存的方案
 * 虚拟内存基于分段和分页两种技术或者只涉及其中的一种
 
#### 7.2.1固定分区
##### 分区大小 
 * 固定分区有两种选择:大小相等的分区和大小不相等的分区
 * 大小相等
		    在分区大小相等中：小于或等于分区大小(例如：每个分区大小为8M)的任何进程都可以
		转入到任何可用的分区中。如果所有的分区都满了，并且没有进程处于就绪态或者运行态，
		则操作系统可以换出一个进程的所有分区，并转入另一个进程，使得处理器有事可做
		
		使用大小相等的固定分区有两个难点：
		** 程序可能太大不能放到一个分区中。这时程序员必须使用覆盖技术设计程序，使得在任何
		   时候该程序只有一部分需要放到主存中。当需要模块不在时，用户程序必须必须把这个模
		   块转入到程序的分区中，覆盖掉该分区中的任何程序和数据
		** 主存的利用率非常第。任何程序，及时很小，都需要占据一个完整的分区。
		   由于被转入数据小于分区大小，从而导致分区内部有空间浪费，这种现象
		   称内存碎片
		   
##### 放置算法
 * 对于大小相等的分区,由于分区大小相等，因而使用哪个分区都没有关系
 * 对于大小不等的分区，有两种方法可以把程序指定到分区。
	1. 最简单的方法把每个进程指定到足够容纳它的最小的分区(每个分区一个队列，多队列)
	   >假定可以知道一个进程最多需要多大的主存空间，但这并不一定能满足。如果不知道一个进程可能
	   >有多大，可行的替代方案是使用覆盖技术或使用虚拟内存
	在这种情况下。每个分区都需要维护一个调度队列，用于保存为这个分区换出的进程，
	优点是可以使每个分区内部分浪费的(内部碎片)最少
	2. 当需要的把一个进程转入主存时，选择可以容纳该进程的最小可用分区。(单队列)
		如果所有分区都已被占据，则必须进行交换。
	> 目前几乎没有什么场合会使用固定分区的方法，使用这种技术的一个成功的操作系统例子
	> 是早期的IBM主机操作系统OS/MFT(具有固定任务数的多道程序设计系统,multiprogramming with
	> a Fixed a Fixed Number of Tasks)
	
#### 7.2.2动态分配
 * 为克服固态分配的缺点，又出现了一种动态分区的方法。但这种方法同样也被很多复杂的
	  内存管理技术所取代。(就是刚开始按照进程大小“连续”的分区，后来的进程去取代之前
	  位置的进程，不行的啊，比之前的那个小，就是出现了空洞了)
 * 对于动态分区，分区长度和数目是可变的
 * 动态分区方法在开始时很好的，但它最终会在内存中出现许多的空洞，随着时间的推移，产生
   越来越多的碎片，内存的利用率随之下降。这种现象成为外部碎片现象，指在所有分区
   外的存储空间越来越多的碎片
 * 克服外部碎片的一种技术是压缩：操作系统不时地移动进程，使得进程所占的空间连续
  ,并且所有空闲空间连城一片。
##### 放置算法
 * 由于压缩非常费时，因而操作系统需要巧妙地把进程分配到内存中，塞住内存中那些“洞”。
 * 可供考虑的有三种放置算法：最佳适配、首次适配、邻近适配。这三种算法都是在主存中
   选择等于或者大于该进程的空闲块。
   1. 最佳适配：选择与要求的大小最接近的块。效率最低
   2. 首次适配：从开始扫描内存，选择大小足够的第一个可用块。效率最高
   3. 邻近适配：从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块
<br/>......
		   
##### 替换算法
  ......
  
#### 7.2.3 伙伴系统
 * 伙伴系统采用称为伙伴的可分割、合并的不同规格的内存块作为分区单位
   在伙伴系统中，可用内存大小为2^K,L <= K <= U,其中
   > 2^L表示分配的最小的尺寸
   > 2^U表示分配的最大块的尺寸;通常2^U是可供分配的整个内存的大小
 * 运用伙伴系统分配内存空间的过程是一个对空闲内存不断对半切分，直到切分出的内存块
   为大于或等于进程大小的最小伙伴为止的过程。回收内存的过程着是不断将相邻空闲伙伴
   合并为更大伙伴单位，直到伙伴不空闲，无法合并为止的过程。
 * 开始时，可用于分配的整个空间被看作是一个大小为2^U的块.如果请求大小s满足2^(U-1)<s
   <=2^U，则分配整个空间。否则，该块被分成两个大小相等的伙伴，大小均为2^(U-1)。如果
   s满足2^(U-2)< s <= 2^(U-1),则对该请求分配两个伙伴中的任何一个；否则其中一个伙伴
   再次分成两半。这个过程直到产生大于或等于s的最小块，并分配给该请求
 * 在任何时候，伙伴系统中维护着一系列“洞”(未分配的块),每个大小为2^i.一个洞可以从（i+1）
   列表中移除，并通过对半分裂在i列表中产生两个大小为2^i的伙伴。当i列表中的一对伙伴
   都变成未分配的块时，它们从该i列表中移除，合并成(i+1)列表中的一个块。请求一个大小
   为k的分配使得2^(i-1)<k <= 2^i时，可使用下面的递归算法找到一个大小为2^i的洞:
   
		void get_hole(int i){
			if(i == (U + 1))
			 <failure>;
			if(i_list empty){
				get_hole(i+1);
				<split hole into buddies>;
				<put buddies on i_list>;
			}
			<take first hole on i_list>;
		}
		
#### 7.2.4重定位
	
	
 